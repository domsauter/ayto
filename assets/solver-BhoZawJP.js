function p(r,o){if(o===0)return[[]];if(r.length===0)return[];if(o===r.length)return[r];const i=r[0],c=r.slice(1),u=p(c,o-1).map(m=>[i,...m]),a=p(c,o);return[...u,...a]}function d(r){try{if(console.log("Solver starting..."),!r.matchingNights||!Array.isArray(r.matchingNights)||r.matchingNights.length===0)return console.log("No matching nights found"),[];const o=r.truthBooths||[],i=new Set;o.forEach(n=>{n.is_perfect_match&&i.add(`${Number(n.couple.man)}-${Number(n.couple.woman)}`)});const c=new Set;o.forEach(n=>{n.is_perfect_match||c.add(`${Number(n.couple.man)}-${Number(n.couple.woman)}`)}),console.log(`Perfect matches: ${[...i]}`),console.log(`No-match pairs: ${[...c]}`);const u=new Set;r.matchingNights.forEach(n=>{n.couples&&Array.isArray(n.couples)&&n.couples.forEach(e=>{const t=`${Number(e.mann)}-${Number(e.frau)}`;c.has(t)||u.add(t)})});let a=[[...i]];return r.matchingNights.forEach((n,e)=>{if(!n.couples||!Array.isArray(n.couples)){console.warn(`Night ${e} has no couples`);return}console.log(`Processing night ${e}: ${n.couples.length} couples, ${n.lights} lights expected`);const t=n.couples.map(l=>`${Number(l.mann)}-${Number(l.frau)}`).filter(l=>!c.has(l)),s=t.filter(l=>i.has(l)).length,h=n.lights-s,b=t.filter(l=>!i.has(l));if(h<0){console.warn(`Night ${e}: more confirmed matches (${s}) than lights (${n.lights}), skipping`);return}const f=p(b,h);console.log(`Night ${e}: ${f.length} valid combinations of ${h} open couples`);const g=[];a.forEach(l=>{f.forEach(N=>{const $=[...new Set([...l,...N])];g.push($)})}),a=g,console.log(`After night ${e}: ${a.length} valid combinations`)}),console.log(`Solver complete: ${a.length} valid combinations`),a.map(n=>{const e={};return n.forEach(t=>{const[s,h]=t.split("-").map(Number);e[s]=h}),e})}catch(o){throw console.error("Error in solve function:",o),o}}function P(r,o){const i=r.candidates.filter(e=>e.gender==="Mann"),c=r.candidates.filter(e=>e.gender==="Frau"),u=new Set,a={},m={};(r.truthBooths||[]).forEach(e=>{e.is_perfect_match?(a[Number(e.couple.man)]=Number(e.couple.woman),m[Number(e.couple.woman)]=Number(e.couple.man)):u.add(`${Number(e.couple.man)}-${Number(e.couple.woman)}`)});const n={men:{},women:{},contradictions:[]};if(i.forEach(e=>{n.men[e.id]={id:e.id,name:e.name,possiblePartners:new Set,certainPartner:null}}),c.forEach(e=>{n.women[e.id]={id:e.id,name:e.name,possiblePartners:new Set,certainPartner:null}}),o.forEach(e=>{Object.entries(e).forEach(([t,s])=>{const h=`${t}-${s}`;u.has(h)||(n.men[t]&&n.men[t].possiblePartners.add(s),n.women[s]&&n.women[s].possiblePartners.add(t))})}),Object.entries(a).forEach(([e,t])=>{e=Number(e),n.men[e]&&(n.men[e].possiblePartners=new Set([t]),n.men[e].certainPartner=t),n.women[t]&&(n.women[t].possiblePartners=new Set([e]),n.women[t].certainPartner=e)}),o.length===1){const e=o[0];Object.entries(e).forEach(([t,s])=>{n.men[t]&&(n.men[t].certainPartner=s),n.women[s]&&(n.women[s].certainPartner=t)})}return i.forEach(e=>{const t=Array.from(n.men[e.id].possiblePartners);n.men[e.id].possiblePartners=t,t.length===0&&n.contradictions.push({type:"no_partner",person:e,gender:"Mann",message:`${e.name} hat keinen möglichen Partner - es gibt einen Widerspruch in den Daten!`})}),c.forEach(e=>{const t=Array.from(n.women[e.id].possiblePartners);n.women[e.id].possiblePartners=t,t.length===0&&n.contradictions.push({type:"no_partner",person:e,gender:"Frau",message:`${e.name} hat keinen möglichen Partner - es gibt einen Widerspruch in den Daten!`})}),n}export{P as a,d as s};
